/**
 * The Bouncy Castle License
 *
 * Copyright (c) 2000-2012 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
 * <p>
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
 * and associated documentation files (the "Software"), to deal in the Software without restriction, 
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * <p>
 * The above copyright notice and this permission notice shall be included in all copies or substantial
 * portions of the Software.
 * <p>
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * 
 * @author Daniele Trabalza <daniele@sics.se> 
 * SICS - Swedish Institute of Computer Science
 * Stockholm, Sweden
 */
package org.spongycastle.crypto.dtls.core.context;

import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import javax.crypto.KeyAgreement;

import org.spongycastle.crypto.dtls.constants.CipherSuite;
import org.spongycastle.crypto.dtls.core.DTLSProtocolHandler;
import org.spongycastle.crypto.dtls.core.RecordLayer;
import org.spongycastle.crypto.dtls.core.SecurityParameters;
import org.spongycastle.crypto.dtls.core.ciphers.CipherFactory;
import org.spongycastle.crypto.dtls.core.ciphers.EncryptionAlgorithm;
import org.spongycastle.crypto.dtls.core.compressions.DTLSNullCompression;
import org.spongycastle.crypto.dtls.core.handshake.Extension;
import org.spongycastle.crypto.dtls.core.handshake.SignatureAndHashAlgorithm;
import org.spongycastle.crypto.dtls.core.keyExchange.DTLSKeyExchange;
import org.spongycastle.crypto.dtls.core.keyExchange.DTLSKeyExchangeFactory;
import org.spongycastle.crypto.dtls.exceptions.NoCMFoundException;
import org.spongycastle.crypto.dtls.exceptions.NoCSFoundException;
import org.spongycastle.crypto.dtls.exceptions.ProgramErrorException;
import org.spongycastle.crypto.dtls.interfaces.DTLSContext;
import org.spongycastle.crypto.dtls.utils.DTLSUtils;
import org.spongycastle.crypto.prng.ThreadedSeedGenerator;
import org.spongycastle.crypto.tls.CompressionMethod;
import org.spongycastle.crypto.tls.ECPointFormat;
import org.spongycastle.crypto.tls.ExtensionType;
import org.spongycastle.crypto.tls.KeyExchangeAlgorithm;
import org.spongycastle.crypto.tls.NamedCurve;
import org.spongycastle.jce.interfaces.ECPublicKey;
import org.spongycastle.jce.spec.ECParameterSpec;
import org.spongycastle.jce.spec.ECPublicKeySpec;
import org.spongycastle.math.ec.ECPoint;

/**
 * This class represents the context that client and server
 * need in order to establish a DTLS connection, authenticate
 * (optionally) each other and generate random numbers in 
 * order to derive session keys
 *
 * @author Daniele Trabalza <daniele@sics.se>
 */
public abstract class DTLSAbstractContext implements DTLSContext{
	
	protected static final Logger LOG = Logger.getLogger(DTLSAbstractContext.class.getName());
	
	//used to generate a secure random
	protected SecureRandom randomGenerator;
	
	protected SecurityParameters securityParameters;
	
	//pre master secret
	protected byte[] preMasterSecret;
	
	//selected cipher suite
	protected int selectedCipherSuite;
	
	//selected compression method
	private int selectedCompressionMethod;
	
	//cipher suites offered by the client
	private int[] offeredCipherSuites;
	
	//compression methods offered by the client
	private short[] offeredCompressionMethods;

	//cookie generated by the server for the first messages
	//the client needs to store it to prepare the second
	//client hello message
	private byte[] cookie;

	/*
	 * This variable stores the reference to the key exchange selected consequently
	 * to the selection of the cipher suites.
	 * If contains informations to be sent and verified.
	 * 
	 */
	protected DTLSKeyExchange keyExchange;

	private List<Extension> offeredExtensions;
	
	//session ID
	//TODO: put field whenever needed

	public DTLSAbstractContext() {
		securityParameters = new SecurityParameters();
	}
	
	public void init(SecureRandom random){
		if (random == null) {
	        /*
	         * We use our threaded seed generator to generate a good random seed. If the user
	         * has a better random seed, he should use the constructor with a SecureRandom.
	         */
	        ThreadedSeedGenerator tsg = new ThreadedSeedGenerator();
	        this.randomGenerator = new SecureRandom();

	        /*
	         * Hopefully, 20 bytes in fast mode are good enough.
	         */
	        this.randomGenerator.setSeed(tsg.generateSeed(20, true));
		} else {
			this.randomGenerator = random;
		}
	}
	
	/**
	 * Available cipherSuites
	 * 2 bytes each
	 * @return
	 */
    public int[] getLocalCipherSuites()
    {
        return new int[] {
        	CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8,
//        	CipherSuite.TLS_PSK_WITH_AES_128_CCM_8,
//        	CipherSuite.TLS_NULL_WITH_NULL_NULL,
        };
    }

    /**
     * Available compression methods
     * @return
     */
    public short[] getLocalCompressionMethods()
    {
        return new short[] { CompressionMethod.NULL };
    }

	public SecureRandom getRandomGenerator() {
		return randomGenerator;
	}

	public SecurityParameters getSecurityParameters() {
		return securityParameters;
	}

	public int getSelectedCipherSuite() {
		return selectedCipherSuite;
	}

	public void setSelectedCipherSuite(int selectedCipgerSuite) {
		this.selectedCipherSuite = selectedCipgerSuite;
	}

	public int getSelectedCompressionMethod() {
		return selectedCompressionMethod;
	}

	public void setSelectedCompressionMethod(int selectedCompressionMethod) {
		this.selectedCompressionMethod = selectedCompressionMethod;
	}

	public int[] getOfferedCipherSuites() {
		return offeredCipherSuites;
	}

	public void setOfferedCipherSuites(int[] offeredCipherSuites) {
		this.offeredCipherSuites = offeredCipherSuites;
	}

	public short[] getOfferedCompressionMethods() {
		return offeredCompressionMethods;
	}
	
	public void setOfferedExtensions(List<Extension> extensions){
		this.offeredExtensions = extensions;
	}

	public List<Extension> getOfferedExtensions() {
		return offeredExtensions;
	}

	public void setOfferedCompressionMethods(short[] offeredCompressionMethods) {
		this.offeredCompressionMethods = offeredCompressionMethods;
	}

	/**
	 * RFC 5246 section 7.4.4
	 * @return
	 */
	public short[] getAcceptableCA() {
		// TODO to implement
		return null;
	}

	public void setCookie(byte[] cookie) {
		this.cookie = cookie;
	}
	
	public byte[] getCookie(){
		return this.cookie;
	}
	
	public void setPreMasterSecret(byte[] preMasterSecret){
		this.preMasterSecret = preMasterSecret;
	}

	/**
	 * Returns an empty pre master secret.
	 * TLS_WITH_NULL_NULL empty pms
	 * @return
	 */
	public byte[] getPreMasterSecret() {
		//wrong
		if (this.preMasterSecret == null)
			return new byte[]{};
		else
			return preMasterSecret;
	}

	/**
	 * This method will select the appropriate cipher suite and
	 * compression method based on the just negotiated cipher suite
	 * @param dtlsProtocolHandler
	 */
	public void selectCipherAndCompression(DTLSProtocolHandler handler){

		//cipher suite selection		
		CipherFactory cipherFactory = new CipherFactory(handler);
		switch (selectedCipherSuite) {
		case CipherSuite.TLS_NULL_WITH_NULL_NULL:
			cipherFactory.prepareNewCipher(EncryptionAlgorithm.NULL, handler.isClient());
			break;

		case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
			cipherFactory.prepareNewCipher(EncryptionAlgorithm.AES_CCM_8, handler.isClient());
			break;

		default:
			break;
		}
		

		//compression method selection
		//TODO: implement compression selection
		handler.setPendingReadCompression(new DTLSNullCompression());
		handler.setPendingWriteCompression(new DTLSNullCompression());
	}
	
	public short[] getClientCertificateTypes() {
		return null;
	}

	public List<SignatureAndHashAlgorithm> getSupportedSignatureAndHashAlgorithms() {
		return null;
	}
	
	/**
	 * This method selects the compression method choosing one
	 * of the offered by the client, with one of the available
	 * from the server
	 * @param context context containing the compression methods of both
	 * client (offered) and server (local)
	 * @return the first matching compression method
	 * @throws NoCMFoundException
	 */
	public short selectCompressionMethod() throws NoCMFoundException {
		//available cipher suites from the server
		short[] availableCM = getLocalCompressionMethods();
		//cipher suites offered by the client
		short[] offeredCM = getOfferedCompressionMethods();
		
		//the first is the most preferred; chose that if available
//		//sort the available list and start from the highest CM
//		Arrays.sort(availableCM);
		
		for (int i = 0; i < offeredCM.length; i++) {
			//if the compression method is available select it
			if (arrayContainsValue(availableCM, offeredCM[i])){
//				System.out.println("Selected CompressionMethod: " + availableCM[i]);
				return availableCM[i];
			}
		}
		
		//no CM found
		throw new NoCMFoundException();
	}

	/**
	 * This method returns true if the value is contained in
	 * the array arr, false otherwise
	 * @param arr
	 * @param i
	 * @return
	 */
	private boolean arrayContainsValue(short[] arr, short i) {
		boolean result = false;
		
		for (int j = 0; j < arr.length; j++) {
			if (arr[j] == i){
				result = true;
				break;
			}
		}
		
		return result;
	}

	/**
	 * This method selects one of the cipher suite offered by the client
	 * or throws an exception if there are no suitable cipher suites
	 * @param context the DTLS context containing the 
	 * list of cipher suites offered by the client and the list
	 * offeref by the server
	 * @return the first matching cipher suite selected by the servers
	 * @throws NoCSFoundException raised when there are no suitable cipher suites
	 */
	public int selectCipherSuite() throws NoCSFoundException {
		//available cipher suites from the server
		int[] availableCS = getLocalCipherSuites();
		//cipher suites offered by the client
		int[] offeredCS = getOfferedCipherSuites();
		
		//the first is the most preferred; chose that if available
//		//sort the available list and start from the highest CS
//		Arrays.sort(availableCS);
		
		for (int i = 0; i < offeredCS.length; i++) {
			//if the cipher suite is available select it
//			if (Arrays.asList(offeredCS).contains(availableCS[i])){
			if (arrayContainsValue(availableCS, offeredCS[i])){
//				System.out.println("Selected CipherSuite: " + availableCS[i]);
				return availableCS[i];
			}
		}
		
		//no CS found
		throw new NoCSFoundException(); 
	}
	

	/**
	 * This method returns true if the value is contained in the array,
	 * false otherwise
	 * @param arr
	 * @param i
	 * @return
	 */
	private boolean arrayContainsValue(int[] arr, int i) {
//		return Arrays.asList(arr).contains(i);

		boolean result = false;
		
		for (int j = 0; j < arr.length; j++) {
			if (arr[j] == i){
				result = true;
				break;
			}
		}
		
		return result;
	}
	
	/**
	 * this method selects and returns the extensions compatible
	 * with this implementation
	 */
	public List<Extension> selectExtensions(boolean client){
	
		/*
		 * For the moment fixed selected extensions.
		 * TODO: if not offered, handle  
		 */
		if (client)
			return getClientHelloExtensions();
		else
			return getServerHelloExtensions();
	}
	
	/**
	 * This method creates and return a server key exchange.
	 * keyExchange is null for PSK 
	 * @param dtlsProtocolHandler
	 * @return
	 * @throws ProgramErrorException 
	 */
	public RecordLayer getServerKeyExchange() throws ProgramErrorException{
		
		selectKeyExchangeMethod();
		
		if (keyExchange == null)
			//no key exchange needed
			return null;
		
		//record to be completed with the key exchange parameters
		RecordLayer serverKeyExchange = RecordLayer.getNewServerKeyExchange(this, keyExchange.getServerKeyExchange(this));

		return serverKeyExchange;
	}

	/**
	 * Instantiates the key exchange according to the cipher suite
	 * previously negotiated. If already present, returns the 
	 * current instance
	 * @throws ProgramErrorException 
	 */
	public void selectKeyExchangeMethod() throws ProgramErrorException {
		if (keyExchange == null){
			//getting the key exchange
			keyExchange = DTLSKeyExchangeFactory.getKeyExchange(selectKeyExchangeAlgorithm(), this);
		}
	}

	/**
	 * Returns a new client key exchange message according to the
	 * previously agreed key exchange method
	 * @throws ProgramErrorException 
	 */
	public RecordLayer getClientKeyExchange() throws ProgramErrorException{
		selectKeyExchangeMethod();
		
		if (keyExchange == null)
			//no key exchange needed
			return null;

		//record to be completed with the key exchange parameters
		RecordLayer clientKeyExchange = RecordLayer.getNewClientKeyExchange(keyExchange.getClientKeyExchange(this));
		
		return clientKeyExchange;
	}
	
	/**
	 * This method selects the key exchange depending on the negotiated cipher suite
	 * @throws ProgramErrorException 
	 */
	protected int selectKeyExchangeAlgorithm() throws ProgramErrorException{
		switch (selectedCipherSuite) {
		case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
			return KeyExchangeAlgorithm.ECDHE_ECDSA;
		default:
			throw new ProgramErrorException("Key exchange selection not yet implemented");
		}
	}
	
	/**
	 * Supported extensions for client and server
	 */
	private List<Extension> getClientHelloExtensions() {
		
		List<Extension> extensions = new ArrayList<Extension>();
		//Extensions
		Extension ext = new Extension();
		ext.setType(ExtensionType.elliptic_curves);
		ext.addSupportedExtensionType(NamedCurve.secp256r1);
		
		extensions.add(ext);
		
		ext = getEcPointFormat();
	
		extensions.add(ext);

		return extensions;
	}

	private Extension getEcPointFormat() {
		Extension ext;
		//extensions
		ext = new Extension();
		ext.setType(ExtensionType.ec_point_formats);
		ext.addSupportedExtensionType(ECPointFormat.uncompressed);

		return ext;
	}
	
	/**
	 * http://tools.ietf.org/html/rfc4492#section-5.2
	 * @return
	 */
	public List<Extension> getServerHelloExtensions() {
		List<Extension> extensions = new ArrayList<Extension>();
		extensions.add(getEcPointFormat());
		return extensions;
	}
	
	/**
	 * 
	 * @param ecPoint
	 * @return
	 * @throws ProgramErrorException 
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeySpecException
	 */
	protected PublicKey decodePublicKey(byte[] ecPoint) throws ProgramErrorException{
		//decode peer's public key
		try{
			//same curve parameters		
			ECParameterSpec params = ((ECPublicKey)keyExchange.getKp().getPublic()).getParameters();
			ECPoint point = params.getCurve().decodePoint(ecPoint);
			KeyFactory keyFactory = KeyFactory.getInstance("ECDH");
			ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
			PublicKey pubKey = keyFactory.generatePublic(spec);
			return pubKey;
		}catch (NoSuchAlgorithmException e) {
			throw new ProgramErrorException("Error obtaining the key factory. " + e);
		} catch (InvalidKeySpecException e) {
			throw new ProgramErrorException("Invalid key specification received " + e);
		}
		
	}
	
	/**
	 * This method calculates the pre master secret from
	 * the public EC point in exchange_keys.
	 * 
	 * First the public key is derived from exchange_keys
	 * and then combined with the private in order to
	 * obtain the shared secret
	 * @throws ProgramErrorException 
	 * 
	 */
	public void calculatePreMasterSecret(byte[] exchange_keys) throws ProgramErrorException{
		try {
			//obtain the public key
			PublicKey pubKey = decodePublicKey(exchange_keys);
	
			//calculate the the shared secret
			KeyAgreement ka = KeyAgreement.getInstance("ECDH");
	    	ka.init(this.keyExchange.getKp().getPrivate());
	    	ka.doPhase(pubKey, true);
	    	
	    	this.preMasterSecret = ka.generateSecret();
	    	
	    	if (preMasterSecret == null){
	    		throw new ProgramErrorException("Error during calculation of the pre master secret; Pre master secret null");
	    	}
	    	LOG.fine("Generated PreMasterSecret from ECDHE with value: " + 
	    			DTLSUtils.getHexString(preMasterSecret));

		} catch (Exception e) {
			LOG.severe("Error during calculation of the pre master secret " + e);
			throw new ProgramErrorException("Error during calculation of the pre master secret " + e);
		}
	}
}
